'''
There is a provably unbreakable cipher called a one-time pad. The way it works is you shift each character of the message by a random amount between 1 and 26 characters, wrapping around the alphabet if necessary. For instance, if the current character is y and the shift is 5, then the new character is d. Each character gets its own shift, so there needs to be as many random shifts as there are characters in the message. As an example, suppose the user enters secret. The program should generate a random shift between 1 and 26 for each character. Suppose the randomly generated shifts are 1, 3, 2, 10, 8, and 2. The encrypted message would be thebmv.

	(a) Write a program that asks the user for a message and encrypts the message using the one-time pad. First convert the string to lowercase. Any spaces and punctuation in the string should be left unchanged. For example, Secret!!! becomes thebmv!!! using the shifts above.
	(b) Write a program to decrypt a string encrypted as above.

The reason it is called a one-time-pad is that the list of random shifts should only be used once. It becomes easily breakable if the same random shifts are used for more than one message. Moreover, it is only provably unbreakable if the random numbers are truly random, and the numbers generated by randint are not truly random. For this problem, just use randint, but for cryptographically safe random numbers, see Section 22.8.
'''


import os, random, string


ALPHABET = string.ascii_lowercase
OTHER_VALID_CHARS = ' ,;:-.!?'


def main() -> None:
	message = get_message()
	shifts = generate_shifts(len(message))
	encrypted_message = encrypt_message(message, shifts)
	display_result(message, shifts, encrypted_message)


def press_any_key_to_continue() -> None:
	input('\nPRESS ANY KEY TO CONTINUE...')


def clear_terminal() -> None:
	os.system('cls' if os.name == 'nt' else 'clear')


def get_message() -> str:
	while True:
		try:
			press_any_key_to_continue()
			clear_terminal()

			message = str(input('Enter a message to be encrypted: ')).lower()

			all_chars_are_valid = all(char.isalpha() or char in OTHER_VALID_CHARS for char in message)

			if len(message.replace(' ', '')) > 0 and all_chars_are_valid:
				return message

			else:
				raise ValueError

		except ValueError:
			print('\nPlease enter a non-empty string using only letters.')


def generate_shifts(message_length: int) -> list[int]:
	shifts = []

	for i in range(message_length):
		shifts.append(random.randint(1, 26))

	return shifts


def encrypt_message(message: str, shifts: list[int]) -> str:
	'''
	Encrypt a message using a one-time pad.
	Letters are shifted forward in the alphabet by an amount determined by the "shifts" list. Non-letter characters are preserved.
	This function assumes that "shifts" has the same length as "message".
	'''
	encrypted_message = ''

	for index, char in enumerate(message):
		if char.isalpha():
			current_index = ALPHABET.index(char)
			current_shift = shifts[index]
			new_index = (current_index + current_shift) % 26
			new_char = ALPHABET[new_index]
		else:
			new_char = char

		encrypted_message += new_char

	return encrypted_message


def display_result(message: str, shifts: list[int], encrypted_message: str) -> None:
	press_any_key_to_continue()
	clear_terminal()

	print(f'Original message: {message}')
	print(f'Shifts: {shifts}')
	print(f'Encrypted message: {encrypted_message}')


if __name__ == '__main__':
	main()